---
title: "STAT547O - Backfitting notes"
author: "Matias Salibian-Barrera"
date: "`r format(Sys.Date())`"
output: github_document
---
  
  ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=5, fig.height=5, 
message=FALSE, warning=FALSE)
```

#### LICENSE
These notes are released under the 
"Creative Commons Attribution-ShareAlike 4.0 International" license. 
See the **human-readable version** [here](https://creativecommons.org/licenses/by-sa/4.0/)
and the **real thing** [here](https://creativecommons.org/licenses/by-sa/4.0/legalcode). 


# DRAFT (Read at your own risk)

## Backfitting (robust and otherwise) "by hand"

We use the Air Quality data.
To simplify the example, we will only use two explanatory variables
(`Wind` and `Temp`):
```{r intro}
library(RBF)
data(airquality)
x <- airquality
x <- x[ complete.cases(x), ]
x <- x[, c('Ozone', 'Solar.R', 'Wind', 'Temp')]
y <- as.vector(x$Ozone)
x <- as.matrix(x[, c('Solar.R', 'Wind', 'Temp')])
```
A scatter plot of the data
```{r scatter, fig.width=7, fig.height=7}
pairs(cbind(y,x), labels=c('Ozone', colnames(x)), pch=19, col='gray30', cex=1.5)
```

### Classical backfitting

The algorithm starts with the estimated intercept (equal to the 
sample mean of the response), and all the components of the additive model
set to zero:
```{r initialize.bf}
alpha.hat <- mean(y)
n <- length(y)
bandw <- 5
f.hat.1 <- f.hat.2 <- f.hat.3 <- rep(0, n)
```
We now compute *partial residuals* without using `f.hat.1`:
```{r partial.1}
r.1 <- y - alpha.hat - f.hat.2 - f.hat.3
```
We smooth this vector of residuals as a function of `x1`
```{r smooth.1}
library(KernSmooth)
oo <- order(x[,1])
tmp <- locpoly(x=x[,1], y=r.1, degree=1, bandwidth=bandw)
tmp.f <- approxfun(x=tmp$x, y=tmp$y)
f.hat.1 <- tmp.f(x[,1])
plot(r.1 ~ x[,1], type='p', pch=19, col='gray30')
lines(f.hat.1[oo] ~ x[oo,1], col='red')
```

Now, compute partial residuals without `f.hat.2` and smooth them 
as a function of `x2`, 
```{r smooth.2}
oo2 <- order(x[,2])
r.2 <- y - alpha.hat - f.hat.1 - f.hat.3
tmp2 <- locpoly(x=x[,2], y=r.2, degree=1, bandwidth=bandw)
tmp2.f <- approxfun(x=tmp2$x, y=tmp2$y)
f.hat.2 <- tmp2.f(x[,2])
plot(r.2 ~ x[,2], type='p', pch=19, col='gray30')
lines(f.hat.2[oo2] ~ x[oo2,2], col='red')
```

Finally, update `f.hat.3`:
```{r smooth.3}
oo3 <- order(x[,3])
r.3 <- y - alpha.hat - f.hat.1 - f.hat.2
tmp3 <- locpoly(x=x[,3], y=r.3, degree=1, bandwidth=bandw)
tmp3.f <- approxfun(x=tmp3$x, y=tmp3$y)
f.hat.3 <- tmp3.f(x[,3])
plot(r.3 ~ x[,3], type='p', pch=19, col='gray30')
lines(f.hat.3[oo3] ~ x[oo3,3], col='red')
```
Iterate
```{r iterate}
f.hat.3 <- f.hat.3 - mean(f.hat.3)
f.hat.2 <- f.hat.2 - mean(f.hat.2)
f.hat.1 <- f.hat.1 - mean(f.hat.1)
for(i in 1:10) {
  f.hat.1.old <- f.hat.1
  f.hat.2.old <- f.hat.2
  f.hat.3.old <- f.hat.3
  
  r.1 <- y - alpha.hat - f.hat.2 -f.hat.3
  tmp <- locpoly(x=x[,1], y=r.1, degree=1, bandwidth=bandw*10)
  tmp.f <- approxfun(x=tmp$x, y=tmp$y)
  f.hat.1 <- tmp.f(x[,1])
  
  r.2 <- y - alpha.hat - f.hat.1 - f.hat.3
  tmp2 <- locpoly(x=x[,2], y=r.2, degree=1, bandwidth=bandw)
  tmp2.f <- approxfun(x=tmp2$x, y=tmp2$y)
  f.hat.2 <- tmp2.f(x[,2])
  
  r.3 <- y - alpha.hat - f.hat.1 - f.hat.2
  tmp3 <- locpoly(x=x[,3], y=r.3, degree=1, bandwidth=bandw)
  tmp3.f <- approxfun(x=tmp3$x, y=tmp3$y)
  f.hat.3 <- tmp3.f(x[,3])
  
  f.hat.3 <- f.hat.3 - mean(f.hat.3)
  f.hat.2 <- f.hat.2 - mean(f.hat.2)
  f.hat.1 <- f.hat.1 - mean(f.hat.1)
  
  print(mean(f.hat.1-f.hat.1.old)^2 + 
          mean(f.hat.2-f.hat.2.old)^2 +
          mean(f.hat.3-f.hat.3.old)^2)
}

plot(r.1 ~ x[,1], type='p', pch=19, col='gray30')
lines(f.hat.1[oo] ~ x[oo,1], col='red')

plot(r.2 ~ x[,2], type='p', pch=19, col='gray30')
lines(f.hat.2[oo2] ~ x[oo2,2], col='red')

plot(r.1 ~ x[,1], type='p', pch=19, col='gray30')
lines(f.hat.1[oo] ~ x[oo,1], col='red')

plot(r.3 ~ x[,3], type='p', pch=19, col='gray30')
lines(f.hat.3[oo3] ~ x[oo3,3], col='red')
```

Sanity check
```{r trygam, message=FALSE, warning=FALSE}
library(gam)
dat <- as.data.frame(x)
dat$Ozone <- y
gg <- predict(gam(Ozone ~ lo(Solar.R, span=.65) +
                  lo(Wind, span=.65) + lo(Temp, span=.65), data=dat),
              type='terms')

plot(r.1 ~ x[,1], type='p', pch=19, col='gray30')
lines(f.hat.1[oo] ~ x[oo,1], col='red')
lines(gg[oo,1] ~ x[oo,1], col='blue')

plot(r.2 ~ x[,2], type='p', pch=19, col='gray30')
lines(f.hat.2[oo2] ~ x[oo2,2], col='red')
lines(gg[oo2,2] ~ x[oo2,2], col='blue')

head(cbind(f.hat.1, gg[,1]))
head(cbind(f.hat.2, gg[,2]))
head(cbind(f.hat.3, gg[,3]))

plot(f.hat.1, gg[,1]); abline(0,1)
plot(f.hat.2, gg[,2]); abline(0,1)
plot(f.hat.3, gg[,3]); abline(0,1)


```



